- ES6中每个js文件是一个模块，有自己的顶级作用域，模块内的变量不会定义在全局
- 不是模块的js都是脚本，脚本type=text/javascript，模块顶部this是undefined


#### 导入

- 导入只执行一次，其他的再次导入不管是不是在这个文件，对被导入的模块js都从第一次执行完，存在内存中的那个实例去获取
-  单个，多个，命名空间导入

> 限制： 模块的导入导出不能出现在表达式语句中，模块是静态解析的，表达式是动态执行的


- 导入看起来像结构，其实不是，导入的变量并不能在当前文件进行修改，只能通过调用一起导入的方法去到导出模块中去对变量进行修改
- 重命名  as 新名字



#### CommonJS和ES6

- Common使用的require语法，引用需要等模块加载完成，在浏览器端这样加载方式不推荐
- Common的引入是拷贝
- Common在运行时加载
- Common有this
- nodejs选择保留requrie是因为在服务端和文件在一起

> 没有绑定任何导出的，直接引用模块就只执行模块，polyfill


#### 浏览器加载js

- type设置为module可以让浏览器按照模块的方式加载
- module类型的内联js代码，在script中间生成一个作用域
- 模块特别在通过import指出所有依赖关系，必须所有的依赖都加载完，模块才会开始执行
- 根据上面特点，浏览器对于module进行defer加载，也就是HTML遇到有src的module就下载，等文档被解析完再开始执行模块
- 多个文件时，按照顺序


> 按顺序扫描所有的模块引用并下载，有3个模块，下载+解析1和1中所有引用资源，依次下载和解析，全部都完成解析之后，开始依次执行，执行1引用资源+执行1，依次执行所有



#### Worker

- 默认是脚本执行的，需要模块要在创建实例时传入第二个指定类型的对象参数
- /  -> 根目录
- ./  -> 当前目录
- ../  -> 父级目录

